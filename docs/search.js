window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "embl_my_genbank.embl_my_genbank", "modulename": "embl_my_genbank.embl_my_genbank", "kind": "module", "doc": "<p>This module can be used as a library for the command line interface\n<code>emb_my_gbk</code>, or as an independent python script. It takes an arbitrarily\ncomplicated Genbank flat file (we tested on a Geneious Prime-exported file\nwith many added annotations and feature qualifiers) and converts it to a\nclean, barebones EMBL file. It can optionally convert this EMBL file with\nadditional restrictions to the Immuno-Polymorphism Database flavor of the\nEMBL format.</p>\n\n<pre><code>usage: embl_my_genbank.py [-h] --gb_path GB_PATH [--metadata METADATA] --species SPECIES [--out_fmt OUT_FMT] [--view_intermediate]\n\noptions:\n  -h, --help            show this help message and exit\n  --gb_path GB_PATH, -g GB_PATH\n                        Genbank file to be converted.\n  --metadata METADATA, -m METADATA\n                        Metadata file with, at minimum, a column of allele names and a column of representative animals.\n  --species SPECIES, -s SPECIES\n                        Scientific name for the species under examination.\n  --out_fmt OUT_FMT, -o OUT_FMT\n                        Format to convert to. Can convert to EMBL, IPD_EMBL, and FASTA.\n  --view_intermediate, -v\n                        Whether to write out the intermediate cleaned Genbank file for inspection.\n</code></pre>\n"}, {"fullname": "embl_my_genbank.embl_my_genbank.parse_command_line_args", "modulename": "embl_my_genbank.embl_my_genbank", "qualname": "parse_command_line_args", "kind": "function", "doc": "<p>Parse command line arguments.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">bool</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "embl_my_genbank.embl_my_genbank.OutType", "modulename": "embl_my_genbank.embl_my_genbank", "qualname": "OutType", "kind": "class", "doc": "<p>Enum for preventing unusuable format requests\nfrom being represented.</p>\n", "bases": "enum.Enum"}, {"fullname": "embl_my_genbank.embl_my_genbank.OutType.EMBL", "modulename": "embl_my_genbank.embl_my_genbank", "qualname": "OutType.EMBL", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;OutType.EMBL: 1&gt;"}, {"fullname": "embl_my_genbank.embl_my_genbank.OutType.IPD_EMBL", "modulename": "embl_my_genbank.embl_my_genbank", "qualname": "OutType.IPD_EMBL", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;OutType.IPD_EMBL: 2&gt;"}, {"fullname": "embl_my_genbank.embl_my_genbank.OutType.GENBANK", "modulename": "embl_my_genbank.embl_my_genbank", "qualname": "OutType.GENBANK", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;OutType.GENBANK: 3&gt;"}, {"fullname": "embl_my_genbank.embl_my_genbank.OutType.FASTA", "modulename": "embl_my_genbank.embl_my_genbank", "qualname": "OutType.FASTA", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;OutType.FASTA: 4&gt;"}, {"fullname": "embl_my_genbank.embl_my_genbank.choose_out_type", "modulename": "embl_my_genbank.embl_my_genbank", "qualname": "choose_out_type", "kind": "function", "doc": "<p>Determines the output file format based on the user's choice.</p>\n\n<p>This function maps a user-provided string indicating the desired\noutput file format to the corresponding format string used by Biopython\nfor file writing. It validates the input against a predefined list of\nacceptable formats and raises an error for invalid inputs.</p>\n\n<p>Args:\n    format_choice (str): A string representing the user's choice of output\n    file format. Expected values correspond to the keys of the <code>OutType</code> enum\n    (e.g., 'EMBL', 'IPD_EMBL', 'GENBANK', 'FASTA').</p>\n\n<p>Returns:\n    str: The string identifier for the output file format as recognized by\n    Biopython (e.g., 'embl', 'genbank', 'fasta').</p>\n\n<p>Raises:\n    ValueError: If the provided <code>format_choice</code> does not correspond to a valid\n    output file format, indicating either a typo or an unsupported format choice.</p>\n\n<p>Example:</p>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>choose_out_type('fasta')\n          'fasta'\n      choose_out_type('genbank')\n          'genbank'\n      choose_out_type('invalid')  # This will raise a ValueError</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n\n<p>Note:\n    The function is case-insensitive for <code>format_choice</code> but expects it to match\n    one of the predefined format keys exactly.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">format_choice</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "embl_my_genbank.embl_my_genbank.handle_allele_id_placement", "modulename": "embl_my_genbank.embl_my_genbank", "qualname": "handle_allele_id_placement", "kind": "function", "doc": "<p>Corrects the placement of allele identifiers in sequence records exported\nfrom Geneious Prime.</p>\n\n<p>Geneious Prime sometimes places allele names in a location that does not\nconform to expected standards for certain analyses or database submissions.\nThis function addresses the issue by relocating the allele name from its original\nposition to both the record's ID and accession fields. It ensures that the allele\nname is consistently represented across the sequence record, facilitating proper\nidentification and reference.</p>\n\n<p>Args:\n    record (SeqRecord): The sequence record to be corrected. This <code>SeqRecord</code> object,\n    as defined by the Biopython library, represents a single sequence and its associated\n    data. The record is expected to have an allele name as part of its naming convention,\n    which will be utilized to update the ID and accession fields.</p>\n\n<p>Returns:\n    SeqRecord: The modified <code>SeqRecord</code> object with the allele name correctly positioned\n    within the ID and accession annotations. This adjustment ensures that the allele name\n    is prominently and correctly displayed in the record, aligning with standard practices\n    for sequence identification.</p>\n\n<p>Raises:\n    AssertionError: If the allele name is not properly propagated to the accession annotation\n    after the function's execution, an AssertionError is raised. This serves as a check to\n    ensure that the intended modifications have been successfully applied to the sequence\n    record.</p>\n\n<p>Example:</p>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>from Bio.Seq import Seq\n      from Bio.SeqRecord import SeqRecord\n      original_record = SeqRecord(Seq(\"AGTC\"), id=\"geneious_id\", name=\"Allele_A1\")\n      corrected_record = handle_allele_id_placement(original_record)\n      corrected_record.id\n          'Allele_A1'\n      corrected_record.annotations[\"accessions\"]\n          ['Allele_A1']</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n\n<p>Note:\n    This function modifies the input <code>SeqRecord</code> object in place by adjusting its ID and\n    annotations. It is designed to ensure that allele names are correctly positioned within\n    the sequence record, reflecting best practices for sequence data management and submission.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">record</span><span class=\"p\">:</span> <span class=\"n\">Bio</span><span class=\"o\">.</span><span class=\"n\">SeqRecord</span><span class=\"o\">.</span><span class=\"n\">SeqRecord</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Bio</span><span class=\"o\">.</span><span class=\"n\">SeqRecord</span><span class=\"o\">.</span><span class=\"n\">SeqRecord</span>:</span></span>", "funcdef": "def"}, {"fullname": "embl_my_genbank.embl_my_genbank.assign_species", "modulename": "embl_my_genbank.embl_my_genbank", "qualname": "assign_species", "kind": "function", "doc": "<p>Assigns a specified species name to the sequence record.</p>\n\n<p>This function updates the 'organism' annotation within the <code>SeqRecord</code> object\nto reflect the specified species' scientific name. This is particularly useful\nfor ensuring consistency in species annotation across multiple sequence records,\nespecially when preparing data for analysis or database submission.</p>\n\n<p>Args:\n    record (SeqRecord): The sequence record to be updated. This is a <code>SeqRecord</code>\n    object as defined by the Biopython library which represents a single sequence\n    and its associated data, including annotations. species (str): The scientific\n    name of the species to be assigned to the sequence record. This name is used\n    to update the 'organism' field within the record's annotations, ensuring that\n    the record accurately reflects the specified species.</p>\n\n<p>Returns:\n    SeqRecord: The modified <code>SeqRecord</code> object with the 'organism' annotation updated\n    to the specified species' scientific name. This ensures that the sequence record\n    is correctly annotated with the appropriate species information for downstream\n    applications.</p>\n\n<p>Example:</p>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>from Bio.Seq import Seq\n      from Bio.SeqRecord import SeqRecord\n      record = SeqRecord(Seq(\"ACTG\"), id=\"example_id\", description=\"An example sequence.\")\n      updated_record = assign_species(record, \"Homo sapiens\")\n      updated_record.annotations[\"organism\"]\n          'Homo sapiens'</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n\n<p>Note:\n    The function modifies the input <code>SeqRecord</code> object in place by updating its\n    'organism' annotation. It also returns the modified <code>SeqRecord</code> object for\n    convenience, allowing further manipulation or analysis if desired.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">record</span><span class=\"p\">:</span> <span class=\"n\">Bio</span><span class=\"o\">.</span><span class=\"n\">SeqRecord</span><span class=\"o\">.</span><span class=\"n\">SeqRecord</span>, </span><span class=\"param\"><span class=\"n\">species</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Bio</span><span class=\"o\">.</span><span class=\"n\">SeqRecord</span><span class=\"o\">.</span><span class=\"n\">SeqRecord</span>:</span></span>", "funcdef": "def"}, {"fullname": "embl_my_genbank.embl_my_genbank.remove_geneious_annotations", "modulename": "embl_my_genbank.embl_my_genbank", "qualname": "remove_geneious_annotations", "kind": "function", "doc": "<p>Removes Geneious-specific annotations from a sequence record.</p>\n\n<p>Geneious software is known to add certain annotations to sequence records that may not\nbe desired in all contexts. This function specifically targets and removes:</p>\n\n<ol>\n<li>\"misc_feature\" features that Geneious adds, often related to manual editing history.</li>\n<li>\"/note\" qualifiers within any feature, which can include comments or metadata added\nby Geneious.</li>\n</ol>\n\n<p>The removal of these annotations can help in simplifying the sequence record for downstream\nanalysis or for submission to databases where such annotations are not required or could\ncause confusion.</p>\n\n<p>Args:\n    record (SeqRecord): The sequence record from which Geneious-specific annotations are\n        to be removed. The record should be a SeqRecord object as defined by the Biopython\n        library, potentially containing features and qualifiers added by Geneious software.</p>\n\n<p>Returns:\n    SeqRecord: The same SeqRecord object passed as input, but modified to remove Geneious-\n        specific annotations. Specifically, all \"misc_feature\" features are removed, and any\n        \"note\" qualifiers within other features are deleted. This ensures the record is cleaner\n        and more compliant with general sequence record standards.</p>\n\n<p>Example:</p>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>from Bio.SeqRecord import SeqRecord\n      from Bio.SeqFeature import SeqFeature, FeatureLocation\n      record = SeqRecord(seq=\"ACTG\", id=\"example\")\n      feature = SeqFeature(FeatureLocation(start=0, end=4), type=\"misc_feature\", qualifiers={\"note\": \"Geneious annotation\"})\n      record.features.append(feature)\n      cleaned_record = remove_geneious_annotations(record)\n      len(cleaned_record.features)\n          0</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n\n<p>Note:\n    The function modifies the input SeqRecord object in place, but also returns it for convenience.\n    This allows for the modified record to be reassigned to the same or a different variable if\n    desired.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">record</span><span class=\"p\">:</span> <span class=\"n\">Bio</span><span class=\"o\">.</span><span class=\"n\">SeqRecord</span><span class=\"o\">.</span><span class=\"n\">SeqRecord</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Bio</span><span class=\"o\">.</span><span class=\"n\">SeqRecord</span><span class=\"o\">.</span><span class=\"n\">SeqRecord</span>:</span></span>", "funcdef": "def"}, {"fullname": "embl_my_genbank.embl_my_genbank.clean_record_features", "modulename": "embl_my_genbank.embl_my_genbank", "qualname": "clean_record_features", "kind": "function", "doc": "<p>Geneious also exports a number of features and feature qualifiers that are\n    unnecessary for our purposes, namely \"standard_name\" and \"gene\". This function does\n    away with those as well, and also adds species and DNA information to the source\n    feature, if available.</p>\n\n<p>Args:\n    record (SeqRecord): The sequence record to be cleaned and updated. A SeqRecord object\n        from Biopython that contains features which may include \"gene\", \"CDS\", and \"source\"\n        types among others.\n    species (str): The species name to be used for updating the \"organism\" qualifier in the\n        \"source\" feature of the record. This string should represent the scientific name of\n        the organism, e.g., \"Homo sapiens\".</p>\n\n<p>Returns:\n    SeqRecord: The modified SeqRecord object with cleaned features according to the\n        specifications. The returned record will have \"gene\" features removed, \"standard_name\"\n        qualifiers deleted from \"CDS\" features where applicable, and the \"source\" feature\n        updated with the provided species name and molecule type set to \"genomic DNA\".</p>\n\n<p>Note:\n    The function directly modifies the input SeqRecord object and also returns this modified\n    object. Therefore, the changes will be reflected in the original SeqRecord passed to the\n    function.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">record</span><span class=\"p\">:</span> <span class=\"n\">Bio</span><span class=\"o\">.</span><span class=\"n\">SeqRecord</span><span class=\"o\">.</span><span class=\"n\">SeqRecord</span>, </span><span class=\"param\"><span class=\"n\">species</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Bio</span><span class=\"o\">.</span><span class=\"n\">SeqRecord</span><span class=\"o\">.</span><span class=\"n\">SeqRecord</span>:</span></span>", "funcdef": "def"}, {"fullname": "embl_my_genbank.embl_my_genbank.read_metadata", "modulename": "embl_my_genbank.embl_my_genbank", "qualname": "read_metadata", "kind": "function", "doc": "<p>Reads metadata from an Excel file and converts it to a dictionary.</p>\n\n<p>This function reads an Excel file containing metadata, specifically looking for\ncolumns named 'Local designation' and 'Animal ID'. It then constructs a dictionary\nwhere 'Local designation' values serve as keys and 'Animal ID' values as corresponding\nvalues.</p>\n\n<p>Args:\n    meta_path (Path): A Path object pointing to the Excel file containing metadata.</p>\n\n<p>Returns:\n    Dict[str, str]: A dictionary mapping 'Local designation' to 'Animal ID'.</p>\n\n<p>Raises:\n    AssertionError: If either 'Local designation' or 'Animal ID' columns are missing\n    from the Excel file.</p>\n\n<p>Example:</p>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>read_metadata(Path('metadata.xlsx'))\n          {'Designation1': 'ID1', 'Designation2': 'ID2', ...}</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n\n<p>Note:\n    The function assumes the Excel file is structured with the specified columns. It\n    raises an assertion error if the expected columns are not found, ensuring the\n    presence of necessary data for further processing.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">meta_path</span><span class=\"p\">:</span> <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "embl_my_genbank.embl_my_genbank.construct_description", "modulename": "embl_my_genbank.embl_my_genbank", "qualname": "construct_description", "kind": "function", "doc": "<p>Constructs a descriptive string for a SeqRecord based on provided metadata.</p>\n\n<p>This function updates the description field of a SeqRecord object based on allele\ninformation, species name, and a dictionary mapping alleles to animal isolates. The\nconstructed description follows a specific format incorporating these elements.</p>\n\n<p>Args:\n    record (SeqRecord): The SeqRecord object to be updated with a new description.\n    species (str): The scientific name of the species.\n    isolate_dict (Dict[str, str]): A dictionary mapping allele names (keys) to\n        animal isolate identifiers (values).</p>\n\n<p>Returns:\n    SeqRecord: The updated SeqRecord object with a new description.</p>\n\n<p>Example:</p>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>from Bio.Seq import Seq\n      record = SeqRecord(Seq(\"ATGC\"), id=\"allele_1\", name=\"allele_1\")\n      construct_description(record, \"Homo sapiens\", {\"allele_1\": \"isolate_1\"})\n          SeqRecord(description=\"Homo sapiens gene for MHC class I antigen (allele_1 gene),\n          isolate isolate_1, allele allele_1\")</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n\n<p>Note:\n    If the allele from the SeqRecord is not found in the provided isolate_dict, the function\n    prints a warning message and returns the SeqRecord unchanged. This ensures the integrity\n    of the SeqRecord's description in cases where metadata may be incomplete or incorrect.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">record</span><span class=\"p\">:</span> <span class=\"n\">Bio</span><span class=\"o\">.</span><span class=\"n\">SeqRecord</span><span class=\"o\">.</span><span class=\"n\">SeqRecord</span>,</span><span class=\"param\">\t<span class=\"n\">species</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">isolate_dict</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Bio</span><span class=\"o\">.</span><span class=\"n\">SeqRecord</span><span class=\"o\">.</span><span class=\"n\">SeqRecord</span>:</span></span>", "funcdef": "def"}, {"fullname": "embl_my_genbank.embl_my_genbank.clean_genbank", "modulename": "embl_my_genbank.embl_my_genbank", "qualname": "clean_genbank", "kind": "function", "doc": "<p>Cleans a GenBank record by updating allele IDs, assigning species names, and\nremoving Geneious annotations.</p>\n\n<p>This function performs a series of cleaning and updating steps on a given GenBank\nsequence record. These steps include correcting the placement of allele IDs, assigning\na scientific name to the species annotation, removing specific Geneious annotations,\nand cleaning various feature annotations added by Geneious software.</p>\n\n<p>Args:\n    record (SeqRecord): The sequence record to be cleaned and updated.\n    species (str): The scientific name of the species to be assigned to the record.</p>\n\n<p>Returns:\n    SeqRecord: The cleaned and updated sequence record.</p>\n\n<p>The function is a wrapper that sequentially applies several specific cleaning and\nupdating operations, making it convenient to perform multiple adjustments through a\nsingle function call.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">record</span><span class=\"p\">:</span> <span class=\"n\">Bio</span><span class=\"o\">.</span><span class=\"n\">SeqRecord</span><span class=\"o\">.</span><span class=\"n\">SeqRecord</span>,</span><span class=\"param\">\t<span class=\"n\">species</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">meta_path</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Bio</span><span class=\"o\">.</span><span class=\"n\">SeqRecord</span><span class=\"o\">.</span><span class=\"n\">SeqRecord</span>:</span></span>", "funcdef": "def"}, {"fullname": "embl_my_genbank.embl_my_genbank.id_line_replacement", "modulename": "embl_my_genbank.embl_my_genbank", "qualname": "id_line_replacement", "kind": "function", "doc": "<p>Replaces the ID line in EMBL-formatted files and writes the modified\nrecords to a new file.</p>\n\n<p>This function first creates an intermediate file from the given sequence\nrecords in the specified output format. It then reads this intermediate file,\nreplaces lines starting with \"ID\" with a predetermined new ID line, and writes\nthe results to a final output file.</p>\n\n<p>Args:\n    records (List[SeqRecord]): A list of SeqRecord objects to be processed.\n    int_embl (str): The path for the intermediate file to be created.\n    final_out (str): The path for the final output file with modified ID lines.\n    out_type (str): The format of the output file (e.g., 'embl', 'genbank').</p>\n\n<p>The function is useful for adjusting file formats that require specific header\nformats not directly supported by the original exporting tool.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">records</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Bio</span><span class=\"o\">.</span><span class=\"n\">SeqRecord</span><span class=\"o\">.</span><span class=\"n\">SeqRecord</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">int_embl</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">final_out</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">out_type</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "embl_my_genbank.embl_my_genbank.write_output", "modulename": "embl_my_genbank.embl_my_genbank", "qualname": "write_output", "kind": "function", "doc": "<p>Writes sequence records to an output file in a specified format, with\noptions for intermediate viewing and format adjustments.</p>\n\n<p>This function supports writing the sequence records to a file in various\nformats. It includes options for creating an intermediate file for review\nand handling special format requirements such as ID line replacements in EMBL\nfiles for IPC entries.</p>\n\n<p>Args:\n    records (List[SeqRecord]): A list of SeqRecord objects to be written to the file.\n    final_out (str): The path for the output file.\n    requested_format (str): The desired format for the output file (e.g., 'EMBL',\n    'IPD_EMBL', 'GENBANK', 'FASTA').\n    view_intermediate (bool): Whether to create and view an intermediate file before\n    final output. Useful for debugging or intermediate analysis.</p>\n\n<p>The function adapts to the requested format, providing flexibility in output file\ngeneration and format-specific handling.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">records</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Bio</span><span class=\"o\">.</span><span class=\"n\">SeqRecord</span><span class=\"o\">.</span><span class=\"n\">SeqRecord</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">final_out</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">requested_format</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">view_intermediate</span><span class=\"p\">:</span> <span class=\"nb\">bool</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "embl_my_genbank.embl_my_genbank.main", "modulename": "embl_my_genbank.embl_my_genbank", "qualname": "main", "kind": "function", "doc": "<p>Coordinate the flow of data through the embl_my_genbank functions.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();